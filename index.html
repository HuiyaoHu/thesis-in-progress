<!DOCTYPE html>
<html lang="en">
	<head>
		<title>211207</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			#buttons {
				position: absolute;
                top: 10px; 
                right: 10px;
			}
			#help {
                color: black; 
                position: absolute; 
                bottom: 10px; 
                right: 10px;
            }
			.button {
                display: block;
                padding: 0px 20px;
                margin: 2px;
                width: 80px;
                height: 40px;
                text-align: center;
                line-height: 40px;
                font-size: 15px;
                cursor: pointer;
			}
			.button.pressed{
				border: 2px solid black;
			}
		</style>
	</head>
	<body>
		<div id="help"> 
			Hold shift to delete.
		</div> 
	</body>
	<div id="buttons"> 
		<div class="button pressed" id="button0" style="background-color:burlywood;">Floor</div>
		<div class="button" id="button1" style="background-color:burlywood;">Wall</div>
		<div class="button" id="button2" style="background-color:burlywood;">Window01</div>
		<div class="button" id="button3" style="background-color:burlywood;">Door01</div>
	</div>
	<script type="module">

		// ------------------------------------------------
		// Import statements
		// ------------------------------------------------

		import * as THREE from 'https://unpkg.com/three@0.119.1/build/three.module.js';
		import { OrbitControls } from 'https://unpkg.com/three@0.119.1/examples/jsm/controls/OrbitControls.js';
		import { GLTFLoader } from 'https://unpkg.com/three@0.119.1/examples/jsm/loaders/GLTFLoader.js';

		// ------------------------------------------------
		// Main code
		// ------------------------------------------------

		var camera, scene, renderer, ground,
			dir_light1, dir_light1_helper, dir_light2, dir_light2_helper, dir_light1ShadowHeper, hemi_light, hemi_light_helper, 
			raycaster, mouse, wall_trans, wall_trans_del, floor_trans, floor_trans_del, Window01_trans, Window01_trans_del, Door01_trans, Door01_trans_del;

		// gltf loader
		var loader = new GLTFLoader();

		
		//materials
		// https://htmlcolorcodes.com/
		// https://www.w3schools.com/colors/colors_names.asp

		var wall_mat = new THREE.MeshLambertMaterial( {
			color: 'burlywood',
		});
		var wall_mat_trans = new THREE.MeshLambertMaterial( {
			color: 'burlywood',
			opacity: 0.2,
			transparent: true,
		});
		var wall_mat_trans_del = new THREE.MeshLambertMaterial( {
			color: 'white',
			opacity: 0.6,
			transparent: true,
		});

		var floor_mat = new THREE.MeshLambertMaterial( {
			color: 0xD3C8AD, //0xAB9F82, 0xD3C8AD, 0xE5DCC7
		});
		var floor_mat_trans = new THREE.MeshLambertMaterial( {
			color: 'burlywood',
			opacity: 0.2,
			transparent: true,
		});
		var floor_mat_trans_del = new THREE.MeshLambertMaterial( {
			color: 'white',
			opacity: 0.6,
			transparent: true,
		});


		var Window01_mat_trans = new THREE.MeshLambertMaterial( {
			color: 'burlywood',
			opacity: 0.2,
			transparent: true,
		});
		var Window01_mat_trans_del = new THREE.MeshLambertMaterial( {
			color: 'white',
			opacity: 0.6,
			transparent: true,
		});

		var Door01_mat_trans = new THREE.MeshLambertMaterial( {
		color: 'burlywood',
		opacity: 0.2,
		transparent: true,
		});
		var Door01_mat_trans_del = new THREE.MeshLambertMaterial( {
			color: 'white',
			opacity: 0.6,
			transparent: true,
		});
		

		var glass = new THREE.MeshLambertMaterial( {
			color: 'turquoise',
			opacity: 0.2,
			transparent: true,
		});
		var obs = new THREE.MeshLambertMaterial( {
			color: 'burlywood',
		});		
		var aluminium = new THREE.MeshLambertMaterial( {
			color: 'gainsboro',
		});
		var rubber = new THREE.MeshLambertMaterial( {
			color: 'black',
		});
		var timber = new THREE.MeshLambertMaterial( {
			color: 'sienna',
		});


		// floor
		var floor_width = 3;
		var floor_length = 3;
		var floor_thickness = 0.45;
		
		var floor_width_half = floor_width/2;

		var floor_geom = new THREE.BoxBufferGeometry( floor_width, floor_length, floor_thickness );
		var floor_geom_trans = new THREE.BoxBufferGeometry( floor_width * 1, floor_length* 1, floor_thickness * 1 );
		var floor_geom_del = new THREE.BoxBufferGeometry( floor_width * 1.1, floor_length* 1.1, floor_thickness * 1.1 );

		
		// wall
		var wall_width = 3;
		var wall_thickness = 0.15;
		var wall_height = 3;
		
		var wall_width_half = wall_width / 2;
		var wall_height_half = wall_height / 2;

		var wall_geom = new THREE.BoxBufferGeometry( wall_width, wall_thickness, wall_height );
		var wall_geom_trans = new THREE.BoxBufferGeometry( wall_width * 1, wall_thickness* 2, wall_height * 1 );
		var wall_geom_del = new THREE.BoxBufferGeometry( wall_width * 1.1, wall_thickness* 3, wall_height * 1.1 );


		// Window01
		var Window01_width = 3;
		var Window01_thickness = 0.5;
		var Window01_height = 3;
		
		var Window01_width_half = Window01_width / 2;
		var Window01_height_half = Window01_height / 2;

		var Window01_geom = new THREE.BoxBufferGeometry( Window01_width, Window01_thickness, Window01_height );
		var Window01_geom_trans = new THREE.BoxBufferGeometry( Window01_width * 1, Window01_thickness* 1, Window01_height * 1 );
		var Window01_geom_del = new THREE.BoxBufferGeometry( Window01_width * 1.1, Window01_thickness* 1.1, Window01_height * 1.1 );

		var  Window01_geom = null
		// Load a glTF resource
		loader.load(
			// resource URL
			'models/Window01.gltf',
			// called when the resource is loaded
			function ( gltf ) {
				Window01_geom = gltf.scene;
				Window01_geom.getObjectByName("Glass").material = glass;
				Window01_geom.getObjectByName("WindowFrame").material = aluminium;
				Window01_geom.getObjectByName("WindowSeal").material = rubber;
				Window01_geom.getObjectByName("SIP").material = obs;
				// Window01_geom.rotation.x += Math.PI /2;
				// Window01_geom.matrixAutoUpdate  = true;
				// Window01_geom.getObjectByName("Window01R001").children.material = new THREE.MeshLambertMaterial( {color: 'burlywood'});
				// Window01_geom.getObjectByName("mesh_36").material = new THREE.MeshLambertMaterial( {color: 'burlywood'});
				// console.log(Window01_geom.getObjectByName("mesh_36").material)
				// console.log(Window01_geom.getObjectByProperty(uuid,  "E01E399B-7EDF-4712-8FD5-574EEE30DF2B" ) )
				// console.log(Window01_geom.getObjectByName("Window01R001").children.material)
			},
			// called when loading has errors
			function ( error ) {	
				console.log( 'An error happened' );
			}
		);
		// Window01_geom.getObjectById("LowpolyBlood_Bake_Blood_0.001").material.color.set( _some_color_ )
		// var Window01_geom = gltf.scene.children[4];


		// Door01
		var Door01_width = 3;
		var Door01_thickness = 0.5;
		var Door01_height = 3;
		
		var Door01_width_half = Door01_width / 2;
		var Door01_height_half = Door01_height / 2;

		var Door01_geom = new THREE.BoxBufferGeometry( Door01_width, Door01_thickness, Door01_height );
		var Door01_geom_trans = new THREE.BoxBufferGeometry( Door01_width * 1, Door01_thickness* 1, Door01_height * 1 );
		var Door01_geom_del = new THREE.BoxBufferGeometry( Door01_width * 1.1, Door01_thickness* 1.1, Door01_height * 1.1 );

		var  Door01_geom = null
		// Load a glTF resource
		loader.load(
			// resource URL
			'models/Door01.gltf',
			// called when the resource is loaded
			function ( gltf ) {
				Door01_geom = gltf.scene;
				Door01_geom.getObjectByName("Door").material = timber;
				Door01_geom.getObjectByName("DoorFrame").material = aluminium;
				Door01_geom.getObjectByName("DoorHandle").material = rubber;
				Door01_geom.getObjectByName("SIP").material = obs;
				// Door01_geom.rotation.x += Math.PI /2;
				// Door01_geom.matrixAutoUpdate  = true;
				// Door01_geom.getObjectByName("Door01R001").children.material = new THREE.MeshLambertMaterial( {color: 'burlywood'});
				// Door01_geom.getObjectByName("mesh_36").material = new THREE.MeshLambertMaterial( {color: 'burlywood'});
				console.log(Door01_geom.getObjectByName("Door"))
				// console.log(Door01_geom.getObjectByProperty(uuid,  "E01E399B-7EDF-4712-8FD5-574EEE30DF2B" ) )
				// console.log(Door01_geom.getObjectByName("Door01R001").children.material)
			},
			// called when loading has errors
			function ( error ) {	
				console.log( 'An error happened' );
			}
		);

		// camera 
		var camera_zoom = 60
		var camera_shift = 3

		// ground
		var num_cells = 6;
		var ground_size = num_cells * wall_width;


		// mouse
		var mouse = new THREE.Vector2();
		var mouse_down = new THREE.Vector2();

		// wall settings
		var walls = {};
		var wall_rotation = 0;
		var wall_pos = null;
		var del_wall = false;
		var wall_counters = [0, 0, 0];
		var wall_pos_list = [];
		
		// floor settings
		var floors = {};
		var floor_pos = null;
		var del_floor = false;
		var floor_counters = [0, 0, 0];

		// Window01 settings
		var Window01s = {};
		var Window01_rotation = 0;
		var Window01_pos = null;
		var del_Window01 = false;
		var Window01_counters = [0, 0, 0];
		var Window01_pos_list = [];

		// Door01 settings
		var Door01s = {};
		var Door01_rotation = 0;
		var Door01_pos = null;
		var del_Door01 = false;
		var Door01_counters = [0, 0, 0];
		var Door01_pos_list = [];

		
		// wall / floor type, relates to the buttons
		var button_index = 0;

		// button ids
		var button_ids = ['button0', 'button1', 'button2', 'button3'];
		

		// execute
		init();
		animate();


		// ------------------------------------------------
		// Initialization function
		// ------------------------------------------------

		function init() {

			// CAMERA AND SCENE

			// camera = new THREE.PerspectiveCamera( 70, Window01.innerWidth / Window01.innerHeight, 1, 10000 ); //FOV, aspect ratio, near, far of clipping plane
			camera = new THREE.OrthographicCamera( -window.innerWidth/camera_zoom+camera_shift, window.innerWidth/camera_zoom+camera_shift,  window.innerHeight/camera_zoom,  -window.innerHeight/camera_zoom, -10000, 10000 ) //( left, right, top, bottom, near, far )
			camera.position.set( 0, 0, 500 );
			camera.up.set( 0, 0, 1 ); //orientation of the camera. if camera. up. set(0,0,1) , it would mean that z-axis is going vertically up in the screen and x and y axes align accordingly.
			scene = new THREE.Scene();

			// SCENE GRID

			var gridGround = new THREE.GridHelper( ground_size, num_cells, 0x504F4F, 0x504F4F );
			gridGround.rotation.x = Math.PI / 2;
			gridGround.position.x = 0;
			gridGround.position.y = -wall_width/2;
			// gridGround.position = (0, -wall_width/2, z)
			// gridGround.position.z = -0.5;
			scene.add( gridGround );
			// var axesHelper = new THREE.AxesHelper( 600 );
			// scene.add( axesHelper )
			
			// GROUND
			// var ground_width = (num_cells-1) * wall_width
			// var ground_height = (num_cells+1) * wall_width
			// var ground_geo = new THREE.PlaneBufferGeometry( ground_width, ground_height); 
			var ground_geo = new THREE.PlaneBufferGeometry( ground_size, ground_size); // width, height
			var ground_mat = new THREE.MeshLambertMaterial( { color: 0xffffff } );
			// var ground_mat = new THREE.MeshStandardMaterial( { color: 'white' } )
			// var ground_mat = new THREE.MeshBasicMaterial( {color: 0x0000ffff, side: THREE.DoubleSide} );
			// ground_mat.color.setHSL( 0.095, 1, 0.75);
			ground = new THREE.Mesh( ground_geo, ground_mat );
			ground.position.set(gridGround.position.x, gridGround.position.y, 0);
			// ground.receiveShadow = true;
			ground.visible = false;
			scene.add( ground );
		
		
			// WIREFRAME BOX

			wall_trans = new THREE.Mesh( wall_geom_trans, wall_mat_trans );
			wall_trans.castShadow = false;
			wall_trans.receiveShadow = false;
			wall_trans.visible = false;
			scene.add(wall_trans);
			wall_trans_del = new THREE.Mesh( wall_geom_del, wall_mat_trans_del );
			wall_trans_del.castShadow = false;
			wall_trans_del.receiveShadow = false;
			wall_trans_del.visible = false;
			scene.add(wall_trans_del);

			floor_trans = new THREE.Mesh( floor_geom_trans, floor_mat_trans );
			floor_trans.castShadow = false;
			floor_trans.receiveShadow = false;
			floor_trans.visible = false;
			scene.add(floor_trans);
			floor_trans_del = new THREE.Mesh( floor_geom_del, floor_mat_trans_del );
			floor_trans_del.castShadow = false;
			floor_trans_del.receiveShadow = false;
			floor_trans_del.visible = false;
			scene.add(floor_trans_del);

			Window01_trans = new THREE.Mesh( Window01_geom_trans, Window01_mat_trans );
			Window01_trans.castShadow = false;
			Window01_trans.receiveShadow = false;
			Window01_trans.visible = false;
			scene.add(Window01_trans);
			Window01_trans_del = new THREE.Mesh( Window01_geom_del, Window01_mat_trans_del );
			Window01_trans_del.castShadow = false;
			Window01_trans_del.receiveShadow = false;
			Window01_trans_del.visible = false;
			scene.add(Window01_trans_del);

			Door01_trans = new THREE.Mesh( Door01_geom_trans, Door01_mat_trans );
			Door01_trans.castShadow = false;
			Door01_trans.receiveShadow = false;
			Door01_trans.visible = false;
			scene.add(Door01_trans);
			Door01_trans_del = new THREE.Mesh( Door01_geom_del, Door01_mat_trans_del );
			Door01_trans_del.castShadow = false;
			Door01_trans_del.receiveShadow = false;
			Door01_trans_del.visible = false;
			scene.add(Door01_trans_del);


			// SCENE BACKGROUND AND FOG

			scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
			scene.fog = new THREE.Fog( scene.background, 1, 7000 );

			// HEMISPHERE LIGHT

			hemi_light = new THREE.HemisphereLight( 0xffffff, 0x3D3D3D, 1.15 ); //  skyColor, groundColor, intensity
			// hemi_light.color.setHSL(  0.6, 0.5, 0.6 );
			//hemi_light.color.setHSL(  0.6, 1, 0.6 );
			hemi_light.position.set( 0, 0, 10 );
			hemi_light.up.set( 0, 0, 0 );
			scene.add( hemi_light );

			// // HEMISPHERE LIGHT HELPER
			// hemi_light_helper = new THREE.HemisphereLightHelper( hemi_light, 1 );
			// scene.add( hemi_light_helper );

			// DIRECTIONAL LIGHT

			dir_light1 = new THREE.DirectionalLight( 0xffffff, 0.3 ); // colour, intensity
			dir_light1.position.set( -5, -2, 0 );
			// dir_light1.position.multiplyScalar( 1 );
			scene.add( dir_light1 );

			dir_light2 = new THREE.DirectionalLight( 0xffffff, 0.3 ); // colour, intensity
			dir_light2.position.set( 5, 2, 0 );
			scene.add( dir_light2 );

			// function hidden_dir_light1_controls(){
			
			// // DIRECTIONAL LIGHT HELPER

			// dir_light1_helper = new THREE.DirectionalLightHelper( dir_light1, 1, 0xFF0000 );
			// scene.add( dir_light1_helper );

			// dir_light2_helper = new THREE.DirectionalLightHelper( dir_light2, 1, 0xFF0000 );
			// scene.add( dir_light2_helper );

			// // DIRECTIONAL LIGHT SHADOWS

			// // dir_light1.castShadow = true;
			// // dir_light1.shadow.mapSize.width = 2048;
			// // dir_light1.shadow.mapSize.height = 2048;
			// // dir_light1.shadow.camera.near = 1;
			// // dir_light1.shadow.camera.far = 3000;
			// // dir_light1.shadow.camera.left = -500;
			// // dir_light1.shadow.camera.bottom = -500;
			// // dir_light1.shadow.camera.top = 500;
			// // dir_light1.shadow.camera.right = 500;

			// // DIRECTIONAL LIGHT SHADOWS HELPER

			// dir_light1ShadowHeper = new THREE.CameraHelper( dir_light1.shadow.camera );
			// scene.add( dir_light1ShadowHeper );
			// }
			
			// RENDERER

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio ); // Sets device pixel ratio. This is usually used for HiDPI device to prevent bluring output canvas.
			renderer.setSize( window.innerWidth, window.innerHeight ); //Resizes the output canvas to (width, height) with device pixel ratio taken into account, and also sets the viewport to fit that size, starting in (0, 0).
			renderer.shadowMap.enabled = true; // Shadow maps are textures the shadows get drawn into.
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
			document.body.appendChild( renderer.domElement );
			
			// ORBIT CONTROL

			var controls = new OrbitControls( camera, renderer.domElement );

			// RAYCASTER

			raycaster = new THREE.Raycaster(); // Raycasting is used for mouse picking (working out what objects in the 3d space the mouse is over) amongst other things.

			// EVENT LISTENERS

			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener('mousedown', onMouseDown, false);
			document.addEventListener('mouseup', onMouseUp, false);
			document.addEventListener( 'mousemove', onMouseMove, false );
			document.getElementById("button0").addEventListener("click", onClickbutton0);
			document.getElementById("button1").addEventListener("click", onClickbutton1);
			document.getElementById("button2").addEventListener("click", onClickbutton2);
			document.getElementById("button3").addEventListener("click", onClickbutton3);

		}

		// ------------------------------------------------
		// Event handeling functions
		// ------------------------------------------------

		// Resize browser window
		function onWindowResize() {
			// camera.aspect = window.innerWidth / window.innerHeight;
			camera.left = -window.innerWidth/camera_zoom+camera_shift;
			camera.right = window.innerWidth/camera_zoom+camera_shift;
			camera.top =  window.innerHeight/camera_zoom;
			camera.bottom =  -window.innerHeight/camera_zoom;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight);
		}

		// Handle mouse click events, save the screen position when mouse down
		function onMouseDown(event) {
			mouse_down.x = event.clientX;
			mouse_down.y = event.clientY
		}

		// Handle mouse click events, 
		// Either create a wall or delete wall
		function onMouseUp(event) {
			if ((mouse_down.x !== event.clientX) || (mouse_down.y !== event.clientY)) {
				// we are dragging, so no nothing
				return;
			}
			if (wall_pos != null) {
				// calc the coords of the wall, to be used for the key
				var coords = new THREE.Vector3(wall_pos.x / wall_width_half, wall_pos.y  / wall_width_half, wall_pos.z / wall_height_half);
				// create a key that is a string that looks something like this: 1_2_3
				var key = coords.x + '_' + coords.y + '_' + coords.z;
				if (del_wall && key in walls) {
					deleteWall(walls[key]);                    
				} else if (!del_wall) {
						// add a new wall
						addWall(coords, key);
				}
			}

			if (floor_pos != null) {
				// calc the coords of the floor, to be used for the key
				var coords = new THREE.Vector3(floor_pos.x / floor_width_half, floor_pos.y  / floor_width_half, floor_pos.z / floor_width_half);
				// create a key that is a string that looks something like this: 1_2_3
				var key = coords.x + '_' + coords.y + '_' + coords.z;
				if (del_floor && key in floors) {
					deletefloor(floors[key]);                    
				} else if (!del_floor) {
					// add a new floor
					addfloor(coords, key);
				}
			}

			if (Window01_pos != null) {
				// calc the coords of the Window01, to be used for the key
				var coords = new THREE.Vector3(Window01_pos.x / Window01_width_half, Window01_pos.y  / Window01_width_half, Window01_pos.z / Window01_height_half);
				// create a key that is a string that looks something like this: 1_2_3
				var key = coords.x + '_' + coords.y + '_' + coords.z;
				if (del_Window01 && key in Window01s) {
					deleteWindow01(Window01s[key]);  
				} else if (!del_Window01) {
					// add a new Window01
					addWindow01(coords, key);
					deleteWall(walls[key]);
					deleteDoor01(Door01s[key]);
				}
			}

			if (Door01_pos != null) {
				// calc the coords of the Door01, to be used for the key
				var coords = new THREE.Vector3(Door01_pos.x / Door01_width_half, Door01_pos.y  / Door01_width_half, Door01_pos.z / Door01_height_half);
				// create a key that is a string that looks something like this: 1_2_3
				var key = coords.x + '_' + coords.y + '_' + coords.z;
				if (del_Door01 && key in Door01s) {
					deleteDoor01(Door01s[key]);  
				} else if (!del_Door01) {
					// add a new Door01
					addDoor01(coords, key);
					deleteWall(walls[key]);
					deleteWindow01(Window01s[key]);
				}
			}
		}

		// Handle mouse move events
		// Store the xy location of the mouse position on the screen, as values between 0 and 1
		// And set the del_item flag and temp wall visibility
		function onMouseMove( event ) {
			event.preventDefault(); // ??? not too sure what this does
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			if (event.shiftKey) {
				del_wall = true;
				wall_trans.visible = false;
			} else {
				del_wall = false;
				wall_trans_del.visible = false;
			}

			if (event.shiftKey) {
				del_floor = true;
				floor_trans.visible = false;
			} else {
				del_floor = false;
				floor_trans_del.visible = false;
			}

			if (event.shiftKey) {
				del_Window01 = true;
				Window01_trans.visible = false;
			} else {
				del_Window01 = false;
				Window01_trans_del.visible = false;
			}
			
			if (event.shiftKey) {
				del_Door01 = true;
				Door01_trans.visible = false;
			} else {
				del_Door01 = false;
				Door01_trans_del.visible = false;
			}
		}
		

		function onClickbutton0() {
			document.getElementById(button_ids[button_index]).classList.remove("pressed");
			button_index = 0;
			document.getElementById(button_ids[button_index]).classList.add("pressed");
		};
		function onClickbutton1() {
			document.getElementById(button_ids[button_index]).classList.remove("pressed");
			button_index = 1;
			document.getElementById(button_ids[button_index]).classList.add("pressed");
		};
		function onClickbutton2() {
			document.getElementById(button_ids[button_index]).classList.remove("pressed");
			button_index = 2;
			document.getElementById(button_ids[button_index]).classList.add("pressed");
		};

		function onClickbutton3() {
			document.getElementById(button_ids[button_index]).classList.remove("pressed");
			button_index = 3;
			document.getElementById(button_ids[button_index]).classList.add("pressed");
		};

		// ------------------------------------------------
		// Animation loop
		// ------------------------------------------------

		// animation loop
		function animate() {
			requestAnimationFrame( animate );
			render();
		}

		// render
		function render() {
			
			if (button_index == 0){
				// get the objects in the scene to check for intersections
				// the floors and the ground
				var isect_objs = Object.values(floors); 
				isect_objs.push(ground);
				// create a ray from the camera and intersect it with objects in the scene
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( isect_objs );

				if ( intersects.length > 0 ) {
					// get the first object that the ray intersects
					var isect0 = intersects[ 0 ];
					if (isect0.object.name == 'floor') {
						// if this is a floor, then get the centre of the floor
						var floor_cen = isect0.object.position;
						floor_pos = new THREE.Vector3(floor_cen.x, floor_cen.y, floor_cen.z);
						if (!del_floor) {
							// if we are adding a new floor, then we offset centre based on the face that was intersected
							if (isect0.faceIndex == 0 || isect0.faceIndex == 1) {
								floor_pos.x += floor_width;
							} else if (isect0.faceIndex == 2 || isect0.faceIndex == 3) {
								floor_pos.x -= floor_width;
							}  else if (isect0.faceIndex == 4 || isect0.faceIndex == 5) {
								floor_pos.y += floor_width;
							}  else if (isect0.faceIndex == 6 || isect0.faceIndex == 7) {
								floor_pos.y -= floor_width;
							}  else if (isect0.faceIndex == 8 || isect0.faceIndex == 9) {
								floor_pos.z += wall_height;
							}  else if (isect0.faceIndex == 10 || isect0.faceIndex == 11) {
								floor_pos.z -= wall_height;
							}
						}
						if (del_floor) {
							// show 'delete' glass floor
							floor_trans_del.position.set(floor_pos.x, floor_pos.y, floor_pos.z);
							floor_trans_del.visible = true;
							floor_trans.visible = false;
						} else {
							// show 'add' glass floor
							floor_trans.position.set(floor_pos.x, floor_pos.y, floor_pos.z);
							floor_trans_del.visible = false;
							floor_trans.visible = true;
						}
					} else {
						// if this is the ground, then get the center from intersection of ground mesh
						if (!del_floor) {
							floor_pos = new THREE.Vector3();
							if (num_cells % 2 == 1) { // odd number of cells
								floor_pos.x = Math.round(isect0.point.x / floor_width) * floor_width;
								floor_pos.y = Math.round(isect0.point.y / floor_width) * floor_width - floor_width_half;
							} else { // even number of cells
								floor_pos.x = Math.round((floor_width_half + isect0.point.x) / floor_width) * floor_width - floor_width_half;
								floor_pos.y = Math.round(isect0.point.y / floor_width) * floor_width ;
							}
							// show 'add' glass floor
							floor_pos.z = 0;
							floor_trans.position.set(floor_pos.x, floor_pos.y, floor_pos.z);
							floor_trans_del.visible = false;
							floor_trans.visible = true;
						}
					}
				} else {
					// the ray intersects with nothing
					// hide the glass floors
					floor_trans.visible = false;
					floor_trans_del.visible = false;
					floor_pos = null;
				}
			}

			if (button_index == 1){
				// get the objects in the scene to check for intersections
				// the walls and the ground
				var isect_objs = Object.values(walls); 
				isect_objs.push(ground);
				// create a ray from the camera and intersect it with objects in the scene
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( isect_objs );

				
				if ( intersects.length > 0 ) { 
					// get the first object that the ray intersects
					var isect0 = intersects[ 0 ];
					if (isect0.object.name == 'wall') { // if this is a wall, then get the centre and rotation of the wall
						var wall_cen = isect0.object.position;
						wall_pos = new THREE.Vector3(wall_cen.x, wall_cen.y, wall_cen.z);
						wall_rotation = isect0.object.rotation.z;

						if (!del_wall) { // if we are adding a new wall, then we offset centre based on the face that was intersected
							// wall_pos.z += wall_height; 
							// console.log('__wall_rotation_',wall_rotation)
							// console.log('__face_',isect0.face)
							// console.log('__distance_',isect0.distance)
							// console.log('__object_',isect0.object)
							// console.log('__uv_',isect0.uv)
							// console.log('___',isect0.faceIndex)
							if (isect0.faceIndex == 0 || isect0.faceIndex == 1) { // right top || right bottom
								if (wall_rotation !== 0) {
									wall_pos.y += wall_width;
								} else {
									wall_pos.x += wall_width;
								}
							} 
							else if (isect0.faceIndex == 3 || isect0.faceIndex == 2) { // left top || left bottom
								if (wall_rotation !== 0) {
									wall_pos.y -= wall_width;
								} else {
									wall_pos.x -= wall_width;
								}
							} 
							else if (isect0.faceIndex == 6) { // front left
								if (wall_rotation !== 0) {
									wall_rotation = 0;
									wall_pos.x += wall_width_half;
									wall_pos.y -= wall_width_half;
								} else {
									wall_rotation = Math.PI / 2;
									wall_pos.x -= wall_width_half;
									wall_pos.y -= wall_width_half;
								}
							}  
							else if (isect0.faceIndex == 7) { // front right
								if (wall_rotation !== 0) {
									wall_rotation = 0;
									wall_pos.x += wall_width_half;
									wall_pos.y += wall_width_half;
								} else {
									wall_rotation = Math.PI / 2;
									wall_pos.x += wall_width_half;
									wall_pos.y -= wall_width_half;
								}
							}  
							else if (isect0.faceIndex == 5) { // back left
								if (wall_rotation !== 0) {
									wall_rotation = 0;
									wall_pos.x -= wall_width_half;
									wall_pos.y += wall_width_half;
								} else {
									wall_rotation = Math.PI / 2;
									wall_pos.x += wall_width_half;
									wall_pos.y += wall_width_half;
								}
							} 
							else if (isect0.faceIndex == 4) { // back right
								if (wall_rotation !== 0) {
									wall_rotation = 0;
									wall_pos.x -= wall_width_half;
									wall_pos.y -= wall_width_half;
								} else {
									wall_rotation = Math.PI / 2;
									wall_pos.x -= wall_width_half;
									wall_pos.y += wall_width_half;
								}
							} 
							else if (isect0.faceIndex == 8 || isect0.faceIndex == 9) { // top left || right
								wall_pos.z += wall_height; 
							}  
							else if (isect0.faceIndex == 11 || isect0.faceIndex == 12) { // bottom left || right
								wall_pos.z -= wall_height; 
							}
						}
						if (del_wall) {
							// show 'delete' glass wall
							wall_trans_del.position.set(wall_pos.x, wall_pos.y, wall_pos.z);
							wall_trans_del.rotation.z = wall_rotation;
							wall_trans_del.visible = true;
							wall_trans.visible = false;
						} else {
							// show 'add' glass wall
							wall_trans.position.set(wall_pos.x, wall_pos.y, wall_pos.z);
							wall_trans.rotation.z = wall_rotation;
							wall_trans_del.visible = false;
							wall_trans.visible = true;
						}
					} 
					
					else { // if this is the ground, then get the center from intersection of ground mesh
						if (!del_wall) {
							wall_pos = new THREE.Vector3();
							wall_rotation = 0
							if (num_cells % 2 == 1) { // odd number of cells
								var ptX = new THREE.Vector3( // wall_pos if wall is horizontal
									Math.round(isect0.point.x / wall_width) * wall_width,
									Math.round(isect0.point.y / wall_width) * wall_width,
									0);
								var ptY = new THREE.Vector3( // wall_pos if wall is vertical
									Math.round((wall_width_half + isect0.point.x) / wall_width) * wall_width - wall_width_half,
									Math.round((wall_width_half + isect0.point.y) / wall_width) * wall_width - wall_width_half,
									0);
							} 
							else { // even number of cells
								var ptX = new THREE.Vector3( // wall_pos if wall is horizontal
									Math.round((wall_width_half + isect0.point.x) / wall_width) * wall_width - wall_width_half,
									Math.round((wall_width_half + isect0.point.y) / wall_width) * wall_width - wall_width_half,
									0);
								var ptY = new THREE.Vector3( // wall_pos if wall is vertical
									Math.round(isect0.point.x / wall_width) * wall_width,
									Math.round(isect0.point.y / wall_width) * wall_width,
									0);
							}
							var distX = ptX.distanceTo(isect0.point); // distance from horizontal wall pos to mouse pointer
							var distY = ptY.distanceTo(isect0.point); // distance from vertical wall pos to mouse pointer
							if (distX <= distY) {
								wall_pos.copy(ptX)
							} else {
								wall_pos.copy(ptY)
								wall_rotation = Math.PI / 2
							}
							// console.log('___', isect0.point, ptX, ptY, distX, distY, wall_pos)

							// show 'add' glass wall
							wall_pos.z = wall_height_half;
							wall_trans.position.set(wall_pos.x, wall_pos.y, wall_pos.z);
							wall_trans.rotation.z = wall_rotation
							wall_trans_del.visible = false;
							wall_trans.visible = true;
						}
					}
				} else { // the ray intersects with nothing, hide the glass walls
					wall_trans.visible = false;
					wall_trans_del.visible = false;
					wall_pos = null;
				}
			}	

			// // shape
			// if (wall_pos_list.length > 3) {
			// 	var geomShape = new THREE.ShapeBufferGeometry(new THREE.Shape(wall_pos_list));
			// 	var matShape = new THREE.MeshBasicMaterial({color:"blue"});
			// 	var shape = new THREE.Mesh(geomShape, matShape);
			// 	// scene.add(shape);
			// 	// console.log('____', wall_pos_list)
			// 	// var geomShape = new THREE.ShapeBufferGeometry(new THREE.Shape(wall_pos_list));
			// }

			if (button_index == 2){
				// get the objects in the scene to check for intersections
				// the Window01s and the ground
				var isect_objs = Object.values(Window01s); 
				isect_objs = isect_objs.concat(Object.values(walls));
				isect_objs = isect_objs.concat(Object.values(Door01s));
				isect_objs.push(ground);
				// create a ray from the camera and intersect it with objects in the scene
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( isect_objs );

				
				if ( intersects.length > 0 ) { 
					// get the first object that the ray intersects
					var isect0 = intersects[ 0 ];
					if (isect0.object.name == 'Window01') { // if this is a Window01, then get the centre and rotation of the Window01
						var Window01_cen = isect0.object.position;
						Window01_pos = new THREE.Vector3(Window01_cen.x, Window01_cen.y, Window01_cen.z);
						Window01_rotation = isect0.object.rotation.z;

						if (!del_Window01) { // if we are adding a new Window01, then we offset centre based on the face that was intersected
							// Window01_pos.z += Window01_height; 
							// console.log('__Window01_rotation_',Window01_rotation)
							// console.log('__face_',isect0.face)
							// console.log('__distance_',isect0.distance)
							console.log('__object_',isect0.object)
							// console.log('__uv_',isect0.uv)
							// console.log('___',isect0.faceIndex)
							if (isect0.faceIndex == 0 || isect0.faceIndex == 1) { // right top || right bottom
								if (Window01_rotation !== 0) {
									Window01_pos.y += Window01_width;
								} else {
									Window01_pos.x += Window01_width;
								}
							} 
							else if (isect0.faceIndex == 3 || isect0.faceIndex == 2) { // left top || left bottom
								if (Window01_rotation !== 0) {
									Window01_pos.y -= Window01_width;
								} else {
									Window01_pos.x -= Window01_width;
								}
							} 
							else if (isect0.faceIndex == 6) { // front left
								if (Window01_rotation !== 0) {
									Window01_rotation = 0;
									Window01_pos.x += Window01_width_half;
									Window01_pos.y -= Window01_width_half;
								} else {
									Window01_rotation = Math.PI / 2;
									Window01_pos.x -= Window01_width_half;
									Window01_pos.y -= Window01_width_half;
								}
							}  
							else if (isect0.faceIndex == 7) { // front right
								if (Window01_rotation !== 0) {
									Window01_rotation = 0;
									Window01_pos.x += Window01_width_half;
									Window01_pos.y += Window01_width_half;
								} else {
									Window01_rotation = Math.PI / 2;
									Window01_pos.x += Window01_width_half;
									Window01_pos.y -= Window01_width_half;
								}
							}  
							else if (isect0.faceIndex == 5) { // back left
								if (Window01_rotation !== 0) {
									Window01_rotation = 0;
									Window01_pos.x -= Window01_width_half;
									Window01_pos.y += Window01_width_half;
								} else {
									Window01_rotation = Math.PI / 2;
									Window01_pos.x += Window01_width_half;
									Window01_pos.y += Window01_width_half;
								}
							} 
							else if (isect0.faceIndex == 4) { // back right
								if (Window01_rotation !== 0) {
									Window01_rotation = 0;
									Window01_pos.x -= Window01_width_half;
									Window01_pos.y -= Window01_width_half;
								} else {
									Window01_rotation = Math.PI / 2;
									Window01_pos.x -= Window01_width_half;
									Window01_pos.y += Window01_width_half;
								}
							} 
							else if (isect0.faceIndex == 8 || isect0.faceIndex == 9) { // top left || right
								Window01_pos.z += Window01_height; 
							}  
							else if (isect0.faceIndex == 11 || isect0.faceIndex == 12) { // bottom left || right
								Window01_pos.z -= Window01_height; 
							}
						}
						if (del_Window01) {
							// show 'delete' glass Window01
							Window01_trans_del.position.set(Window01_pos.x, Window01_pos.y, Window01_pos.z);
							Window01_trans_del.rotation.z = Window01_rotation;
							Window01_trans_del.visible = true;
							Window01_trans.visible = false;
						} else {
							// show 'add' glass Window01
							Window01_trans.position.set(Window01_pos.x, Window01_pos.y, Window01_pos.z);
							Window01_trans.rotation.z = Window01_rotation;
							Window01_trans_del.visible = false;
							Window01_trans.visible = true;
						}
					} 
					
					else if (isect0.object.name == 'wall') { // if this is the ground, then get the center from intersection of ground mesh
						if (!del_Window01) {
							// console.log('____', isect0.object.name)
							// Window01_pos = new THREE.Vector3();
							// Window01_rotation = 0
							// if (num_cells % 2 == 1) { // odd number of cells
							// 	var ptX = new THREE.Vector3( // Window01_pos if Window01 is horizontal
							// 		Math.round(isect0.point.x / Window01_width) * Window01_width,
							// 		Math.round(isect0.point.y / Window01_width) * Window01_width,
							// 		0);
							// 	var ptY = new THREE.Vector3( // Window01_pos if Window01 is vertical
							// 		Math.round((Window01_width_half + isect0.point.x) / Window01_width) * Window01_width - Window01_width_half,
							// 		Math.round((Window01_width_half + isect0.point.y) / Window01_width) * Window01_width - Window01_width_half,
							// 		0);
							// } 
							// else { // even number of cells
							// 	var ptX = new THREE.Vector3( // Window01_pos if Window01 is horizontal
							// 		Math.round((Window01_width_half + isect0.point.x) / Window01_width) * Window01_width - Window01_width_half,
							// 		Math.round((Window01_width_half + isect0.point.y) / Window01_width) * Window01_width - Window01_width_half,
							// 		0);
							// 	var ptY = new THREE.Vector3( // Window01_pos if Window01 is vertical
							// 		Math.round(isect0.point.x / Window01_width) * Window01_width,
							// 		Math.round(isect0.point.y / Window01_width) * Window01_width,
							// 		0);
							// }
							// var distX = ptX.distanceTo(isect0.point); // distance from horizontal Window01 pos to mouse pointer
							// var distY = ptY.distanceTo(isect0.point); // distance from vertical Window01 pos to mouse pointer
							// if (distX <= distY) {
							// 	Window01_pos.copy(ptX)
							// } else {
							// 	Window01_pos.copy(ptY)
							// 	Window01_rotation = Math.PI / 2
							// }
							// console.log('___', isect0.point, ptX, ptY, distX, distY, Window01_pos)

							// show 'add' glass Window01
							var Window01_cen = isect0.object.position;
							Window01_pos = new THREE.Vector3(Window01_cen.x, Window01_cen.y, Window01_cen.z);
							Window01_rotation = isect0.object.rotation.z;

							// Window01_pos.z = Window01_height_half;
							Window01_trans.position.copy(Window01_pos);
							Window01_trans.rotation.z = Window01_rotation
							Window01_trans_del.visible = false;
							Window01_trans.visible = true;
						}
					}
				} else { // the ray intersects with nothing, hide the glass Window01s
					Window01_trans.visible = false;
					Window01_trans_del.visible = false;
					Window01_pos = null;
				}
			}	

			if (button_index == 3){
				// get the objects in the scene to check for intersections
				// the Door01s and the ground
				var isect_objs = Object.values(Door01s); 
				isect_objs = isect_objs.concat(Object.values(walls));
				isect_objs.push(ground);
				// create a ray from the camera and intersect it with objects in the scene
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( isect_objs );

				
				if ( intersects.length > 0 ) { 
					// get the first object that the ray intersects
					var isect0 = intersects[ 0 ];
					if (isect0.object.name == 'Door01') { // if this is a Door01, then get the centre and rotation of the Door01
						var Door01_cen = isect0.object.position;
						Door01_pos = new THREE.Vector3(Door01_cen.x, Door01_cen.y, Door01_cen.z);
						Door01_rotation = isect0.object.rotation.z;

						if (!del_Door01) { // if we are adding a new Door01, then we offset centre based on the face that was intersected
							// Door01_pos.z += Door01_height; 
							// console.log('__Door01_rotation_',Door01_rotation)
							// console.log('__face_',isect0.face)
							// console.log('__distance_',isect0.distance)
							console.log('__object_',isect0.object)
							// console.log('__uv_',isect0.uv)
							// console.log('___',isect0.faceIndex)
							if (isect0.faceIndex == 0 || isect0.faceIndex == 1) { // right top || right bottom
								if (Door01_rotation !== 0) {
									Door01_pos.y += Door01_width;
								} else {
									Door01_pos.x += Door01_width;
								}
							} 
							else if (isect0.faceIndex == 3 || isect0.faceIndex == 2) { // left top || left bottom
								if (Door01_rotation !== 0) {
									Door01_pos.y -= Door01_width;
								} else {
									Door01_pos.x -= Door01_width;
								}
							} 
							else if (isect0.faceIndex == 6) { // front left
								if (Door01_rotation !== 0) {
									Door01_rotation = 0;
									Door01_pos.x += Door01_width_half;
									Door01_pos.y -= Door01_width_half;
								} else {
									Door01_rotation = Math.PI / 2;
									Door01_pos.x -= Door01_width_half;
									Door01_pos.y -= Door01_width_half;
								}
							}  
							else if (isect0.faceIndex == 7) { // front right
								if (Door01_rotation !== 0) {
									Door01_rotation = 0;
									Door01_pos.x += Door01_width_half;
									Door01_pos.y += Door01_width_half;
								} else {
									Door01_rotation = Math.PI / 2;
									Door01_pos.x += Door01_width_half;
									Door01_pos.y -= Door01_width_half;
								}
							}  
							else if (isect0.faceIndex == 5) { // back left
								if (Door01_rotation !== 0) {
									Door01_rotation = 0;
									Door01_pos.x -= Door01_width_half;
									Door01_pos.y += Door01_width_half;
								} else {
									Door01_rotation = Math.PI / 2;
									Door01_pos.x += Door01_width_half;
									Door01_pos.y += Door01_width_half;
								}
							} 
							else if (isect0.faceIndex == 4) { // back right
								if (Door01_rotation !== 0) {
									Door01_rotation = 0;
									Door01_pos.x -= Door01_width_half;
									Door01_pos.y -= Door01_width_half;
								} else {
									Door01_rotation = Math.PI / 2;
									Door01_pos.x -= Door01_width_half;
									Door01_pos.y += Door01_width_half;
								}
							} 
							else if (isect0.faceIndex == 8 || isect0.faceIndex == 9) { // top left || right
								Door01_pos.z += Door01_height; 
							}  
							else if (isect0.faceIndex == 11 || isect0.faceIndex == 12) { // bottom left || right
								Door01_pos.z -= Door01_height; 
							}
						}
						if (del_Door01) {
							// show 'delete' glass Door01
							Door01_trans_del.position.set(Door01_pos.x, Door01_pos.y, Door01_pos.z);
							Door01_trans_del.rotation.z = Door01_rotation;
							Door01_trans_del.visible = true;
							Door01_trans.visible = false;
						} else {
							// show 'add' glass Door01
							Door01_trans.position.set(Door01_pos.x, Door01_pos.y, Door01_pos.z);
							Door01_trans.rotation.z = Door01_rotation;
							Door01_trans_del.visible = false;
							Door01_trans.visible = true;
						}
					} 
					
					else if (isect0.object.name == 'wall') { // if this is the ground, then get the center from intersection of ground mesh
						if (!del_Door01) {
							// console.log('____', isect0.object.name)
							// Door01_pos = new THREE.Vector3();
							// Door01_rotation = 0
							// if (num_cells % 2 == 1) { // odd number of cells
							// 	var ptX = new THREE.Vector3( // Door01_pos if Door01 is horizontal
							// 		Math.round(isect0.point.x / Door01_width) * Door01_width,
							// 		Math.round(isect0.point.y / Door01_width) * Door01_width,
							// 		0);
							// 	var ptY = new THREE.Vector3( // Door01_pos if Door01 is vertical
							// 		Math.round((Door01_width_half + isect0.point.x) / Door01_width) * Door01_width - Door01_width_half,
							// 		Math.round((Door01_width_half + isect0.point.y) / Door01_width) * Door01_width - Door01_width_half,
							// 		0);
							// } 
							// else { // even number of cells
							// 	var ptX = new THREE.Vector3( // Door01_pos if Door01 is horizontal
							// 		Math.round((Door01_width_half + isect0.point.x) / Door01_width) * Door01_width - Door01_width_half,
							// 		Math.round((Door01_width_half + isect0.point.y) / Door01_width) * Door01_width - Door01_width_half,
							// 		0);
							// 	var ptY = new THREE.Vector3( // Door01_pos if Door01 is vertical
							// 		Math.round(isect0.point.x / Door01_width) * Door01_width,
							// 		Math.round(isect0.point.y / Door01_width) * Door01_width,
							// 		0);
							// }
							// var distX = ptX.distanceTo(isect0.point); // distance from horizontal Door01 pos to mouse pointer
							// var distY = ptY.distanceTo(isect0.point); // distance from vertical Door01 pos to mouse pointer
							// if (distX <= distY) {
							// 	Door01_pos.copy(ptX)
							// } else {
							// 	Door01_pos.copy(ptY)
							// 	Door01_rotation = Math.PI / 2
							// }
							// console.log('___', isect0.point, ptX, ptY, distX, distY, Door01_pos)

							// show 'add' glass Door01
							var Door01_cen = isect0.object.position;
							Door01_pos = new THREE.Vector3(Door01_cen.x, Door01_cen.y, Door01_cen.z);
							Door01_rotation = isect0.object.rotation.z;

							// Door01_pos.z = Door01_height_half;
							Door01_trans.position.copy(Door01_pos);
							Door01_trans.rotation.z = Door01_rotation
							Door01_trans_del.visible = false;
							Door01_trans.visible = true;
						}
					}
				} else { // the ray intersects with nothing, hide the glass Door01s
					Door01_trans.visible = false;
					Door01_trans_del.visible = false;
					Door01_pos = null;
				}
			}	


			// render the scene
			renderer.render( scene, camera );
		}

		// ------------------------------------------------
		// Helper functions
		// -----------------------------------------------

		
		// Add a wall
		function addWall(coords, key) {
			// create the wall
			if  (walls[key]) {return;} // prevent overlap
			var wall = new THREE.Mesh( wall_geom, wall_mat );
			wall.castShadow = true;
			wall.receiveShadow = true;
			wall.position.set(wall_pos.x, wall_pos.y, wall_pos.z);
			// set wall properties
			wall.name = "wall"
			wall.button_index = button_index;
			wall.wall_coords = coords;
			wall.wall_key = key;
			// add the wall
			scene.add( wall );
			walls[key] = wall;
			wall.rotation.z = wall_rotation;
			// increase the count
			wall_counters[button_index] += 1; 
			// update the counter on the web page
			document.getElementById(button_ids[button_index]).innerHTML = "Wall: " + wall_counters[button_index];
			

			// // get wall corner points
			// const corner_ver_shift_value = new THREE.Vector3(0, 0, wall_height_half);
			// var corner_hor_shift_value = 0;
			// if (wall_rotation == 0) {
			// 	var corner_shift_value = new THREE.Vector3(wall_width_half, 0, 0);
			// }
			// else {
			// 	var corner_shift_value = new THREE.Vector3(0, wall_width_half*(-1), 0);
			// }
			// var wall_left_corner = wall.position.clone().sub(corner_shift_value).sub(corner_ver_shift_value) ;
			// var wall_right_corner = wall.position.clone().add(corner_shift_value).sub(corner_ver_shift_value);
			// wall_pos_list.push(wall_left_corner, wall_right_corner);

			// // Visualise Points
			// var geom = new THREE.BufferGeometry().setFromPoints([wall_left_corner, wall_right_corner]);
			// var matPoints = new THREE.PointsMaterial({size: 10, color: "pink"});
			// var points = new THREE.Points(geom, matPoints);
			// scene.add(points);
	
			// console.log('____', wall_pos_list)
		}

		// Delete a wall
		function deleteWall(wall) {
			// if (!wall) { return; }
			// decrease the count
			wall_counters[wall.button_index] -= 1; 
			// update the counter on the web page
			document.getElementById(button_ids[wall.button_index]).innerHTML = "Wall: " + wall_counters[wall.button_index];
			// delete the wall
			delete walls[ wall.wall_key ];
			scene.remove( wall );
			wall_pos_list.pop(wall.position);
			// console.log('____', wall_pos_list)
		}

		// Add a floor
		function addfloor(coords, key) {
			// create the floor
			var floor = new THREE.Mesh( floor_geom, floor_mat );
			floor.castShadow = true;
			floor.receiveShadow = true;
			floor_pos.z+=Window01_thickness/2
			floor.position.set(floor_pos.x, floor_pos.y, floor_pos.z);
			// set floor properties
			floor.name = "floor"
			floor.button_index = button_index;
			floor.floor_coords = coords;
			floor.floor_key = key;
			// add the floor
			scene.add( floor );
			floors[key] = floor;
			// increase the count
			floor_counters[button_index] += 1; 
			// update the counter on the web page
			document.getElementById(button_ids[button_index]).innerHTML = "Floor: " + floor_counters[button_index];
		}

		// Delete a floor
		function deletefloor(floor) {
			// decrease the count
			floor_counters[floor.button_index] -= 1; 
			// update the counter on the web page
			document.getElementById(button_ids[floor.button_index]).innerHTML = "Floor:" + floor_counters[floor.button_index];
			// delete the floor
			delete floors[ floor.floor_key ];
			scene.remove( floor );
		}

			
		// Add a Window01
		function addWindow01(coords, key) {
			// create the Window01
			if  (Window01s[key]) {return;} // prevent overlap
			var Window01 = Window01_geom.clone();
			Window01.castShadow = true;
			Window01.receiveShadow = true;
			Window01.position.set(Window01_pos.x, Window01_pos.y, Window01_pos.z);
			// set Window01 properties
			Window01.name = "Window01"
			Window01.button_index = button_index;
			Window01.Window01_coords = coords;
			Window01.Window01_key = key;
			// add the Window01
			scene.add( Window01 );
			Window01s[key] = Window01;
			Window01.rotation.z = Window01_rotation;
			// Window01.rotation.y = Window01_rotation;
			// increase the count
			Window01_counters[button_index] += 1; 
			// update the counter on the web page
			document.getElementById(button_ids[button_index]).innerHTML = "Window01: " + Window01_counters[button_index];
		}

		// Delete a Window01
		function deleteWindow01(Window01) {
			// decrease the count
			Window01_counters[Window01.button_index] -= 1; 
			// update the counter on the web page
			document.getElementById(button_ids[Window01.button_index]).innerHTML = "Window01: " + Window01_counters[Window01.button_index];
			// delete the Window01
			delete Window01s[ Window01.Window01_key ];
			scene.remove( Window01 );
			Window01_pos_list.pop(Window01.position);
			// console.log('____', Window01_pos_list)
		}

		// Add a Door01
		function addDoor01(coords, key) {
			// create the Door01
			if  (Door01s[key]) {return;} // prevent overlap
			var Door01 = Door01_geom.clone();
			Door01.castShadow = true;
			Door01.receiveShadow = true;
			Door01.position.set(Door01_pos.x, Door01_pos.y, Door01_pos.z);
			// set Door01 properties
			Door01.name = "Door01"
			Door01.button_index = button_index;
			Door01.Door01_coords = coords;
			Door01.Door01_key = key;
			// add the Door01
			scene.add( Door01 );
			Door01s[key] = Door01;
			Door01.rotation.z = Door01_rotation;
			// Door01.rotation.y = Door01_rotation;
			// increase the count
			Door01_counters[button_index] += 1; 
			// update the counter on the web page
			document.getElementById(button_ids[button_index]).innerHTML = "Door01: " + Door01_counters[button_index];
		}

		// Delete a Door01
		function deleteDoor01(Door01) {
			// decrease the count
			Door01_counters[Door01.button_index] -= 1; 
			// update the counter on the web page
			document.getElementById(button_ids[Door01.button_index]).innerHTML = "Door01: " + Door01_counters[Door01.button_index];
			// delete the Door01
			delete Door01s[ Door01.Door01_key ];
			scene.remove( Door01 );
			Door01_pos_list.pop(Door01.position);
			// console.log('____', Door01_pos_list)
		}


	</script>
</html>